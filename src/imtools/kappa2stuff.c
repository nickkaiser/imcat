#define usage "\n\n\n\
NAME\n\
	kappa2stuff --- generate shear etc from surface density\n\
\n\
SYNOPSIS\n\
	kappa2stuff [options...] \n\
		-f Nx Ny	# set size of fft box\n\
\n\
DESCRIPTION\n\
	\"kappa2stuff\" reads a fits file containing a smooth kappa\n\
	image (perhaps generated by \"lightmap ... ... | smooth ...\")\n\
	and generates a grid of distortion, shear, deflection etc values.\n\
	By default it does an FFT in a box twice size of original\n\
	image to remove periodic BC effects.  Use -f option to\n\
	to set size of FFT (must be bigger than actual image)\n\
	The output is in 'lc' catalogue format with items:\n\
		x[2]		# position\n\
		kappa		# surface density as input\n\
		def[2]		# deflection\n\
		lambda[2]	# eigenvalues of distortion tensor\n\
		e[2]		# distortion\n\
		R		# axis ratio\n\
		phi		# position angle\n\
		parity		# parity\n\
		amp		# magnification\n\
\n\
AUTHOR\n\
	Nick Kaiser:  kaiser@cita.utoronto.ca\n\
\n\n\n"


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


#include "../imlib/fits.h"
#include "../fftlib/myfft.h"
#include "../utils/error.h"

#define PI	M_PI


float	zero(float kx, float ky);
float	def1(float kx, float ky);
float	def2(float kx, float ky);
float	gamma1(float kx, float ky);
float	gamma2(float kx, float ky);

int		main(int argc, char *argv[])	
{
	int		arg = 1;
	int		i, j, N1, N2, Nx, Ny, mode, parity;
	fitsheader	*fits;
	float		**kappain, **kappa;
	float		**d1, **d2, **g1, **g2, dist1, dist2, phi, R, dd, d, mag, g, gg, l11, l22;
	fft_type	kappak;
	FILE		*lcpipe;

	/* default behaviour */
	Nx = Ny = 0;

	/* parse args */
	while (arg < argc) {
		if (argv[arg][0] != '-')
			error_exit(usage);
		switch (argv[arg++][1]) {
			case 'f':
				sscanf(argv[arg++], "%d", &Nx);
				sscanf(argv[arg++], "%d", &Ny);
				break;
			default:
				error_exit(usage);
		}
	}

	/* read the fits file */
	read2Dfloatimage(&kappain, &N1, &N2, &fits, stdin);

	/* figure size of fft */
	if (Nx) {
		if (Nx < N1 || Ny < N2)
			error_exit("kappa2stuff: FFT box too small\n");
	} else {
		Nx = 2 * N1;
		Ny = 2 * N2;
	}

	/* create Nx by Ny array kappa */
	allocFloatArray(&kappa, Nx, Ny);
	for (i = 0; i < N2; i++)
		for (j = 0; j < N1; j++)
			kappa[i][j] = kappain[i][j];

	/* allocate space for the fourier transform and results*/
	alloc_fft(&kappak, Nx, Ny);
	allocFloatArray(&d1, Nx, Ny);
	allocFloatArray(&d2, Nx, Ny);
	allocFloatArray(&g1, Nx, Ny);
	allocFloatArray(&g2, Nx, Ny);
	
	/* now do the appropriate transform and inverse transform */
	forward_fft(kappa, Nx, Ny, kappak);
	cfilter(kappak, Nx, Ny, zero, def1);
	inverse_fft(kappak, Nx, Ny, d1);
	forward_fft(kappa, Nx, Ny, kappak);
	cfilter(kappak, Nx, Ny, zero, def2);
	inverse_fft(kappak, Nx, Ny, d2);
	forward_fft(kappa, Nx, Ny, kappak);
	filter(kappak, Nx, Ny, gamma1);
	inverse_fft(kappak, Nx, Ny, g1);
	forward_fft(kappa, Nx, Ny, kappak);
	filter(kappak, Nx, Ny, gamma2);
	inverse_fft(kappak, Nx, Ny, g2);

/*
	fprintf(stdout, "# %5d %5d\n", N1, N2);
	fprintf(stdout, "#    i      j      kappa       def1       def2   lambda11   lambda22 \
     dist1      dist2          R        phi parity magnification\n");
*/
	lcpipe = popen("lc -C -b -x -a kappa2stuff -d -N '1 2 x' -n kappa -N '1 2 def' -N '1 2 lambda' -N '1 2 e' -n R -n phi -n parity -n mag", "w");
	if (!lcpipe)
		error_exit("kappa2stuff: failed to open output pipe\n");
	for (i = 0; i < N2; i++) {
		for (j = 0; j < N1; j++) {
			if (kappa[i][j] != 1.0) {
				dist1 = g1[i][j] / (1 - kappa[i][j]);
				dist2 = g2[i][j] / (1 - kappa[i][j]);
			} else {
				dist1 = dist2 = 0.0;
			}
			dd = dist1 * dist1 + dist2 * dist2;
			parity = 1;
			if (dd > 1.0) {
				parity = -1;
				dist1 /= dd;
				dist2 /= dd;
			} 
			phi = 0.5 * atan2(dist2, dist1);
			d = sqrt(dist1 * dist1 + dist2 * dist2);
			R = (1 - d) / (1 + d);
			gg = g1[i][j] * g1[i][j] + g2[i][j] * g2[i][j];
			mag = fabs((1 - kappa[i][j]) * (1 - kappa[i][j]) - gg);
			g = sqrt(gg);
			l11 = 1 - kappa[i][j] - g;
			l22 = 1 - kappa[i][j] + g;
			if (mag != 0.0)
				mag = 1.0 / mag;
			fprintf(lcpipe, "%13g %13g %13g %13g %13g %13g %13g %13g %13g %13g %13g %d %13g\n",
				j + 0.5, i + 0.5, kappa[i][j], d1[i][j], d2[i][j], l11, l22, dist1, dist2, R, phi, parity, mag);
		}
	}
	pclose(lcpipe);
	exit(0);
}


float	zero(float kx, float ky)
{
	return (0.0);
}



float	def1(float kx, float ky)
{
	float	kk;

	if (kx == 0.0 && ky == 0.0)
		return (0.0);
	kk = kx * kx + ky * ky;
	return (2 * kx / kk);	
}



float	def2(float kx, float ky)
{
	float	kk;

	if (kx == 0.0 && ky == 0.0)
		return (0.0);
	kk = kx * kx + ky * ky;
	return (2 * ky / kk);	
}


float	gamma1(float kx, float ky)
{
	float	kk;

	if (kx == 0.0 && ky == 0.0)
		return (0.0);
	kk = kx * kx + ky * ky;
	return ((kx * kx - ky * ky) / kk);	
}


float	gamma2(float kx, float ky)
{
	float	kk;

	if (kx == 0.0 && ky == 0.0)
		return (0.0);
	kk = kx * kx + ky * ky;
	return (2 * kx * ky / kk);	
}


