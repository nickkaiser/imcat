/*
 * invgrad.c
 */

#define usage "\n\
NAME\n\
	invgrad - take the inverse gradient of a FITS image\n\
\n\
SYNOPSIS\n\
	invgrad\n\
\n\
DESCRIPTION\n\
	'invgrad' applies inverse gradient operator to a gradient image\n\
	using the FFT.  It reads a N1 by N2 by 2 image from stdin (in format\n\
	as generated by 'grad') and writes N1 by N2 image to stdout.\n\
	It works by first 'fixing' the end coumn of df/dx\n\
	and the last row of df/dy to enforce periodic boundary conditions\n\
	and we then apply the inverse discrete difference operator in k-space\n\
	to generate two inverse gradient images (one from df/dx, one from\n\
	df/dy) and we then combine these with weights\n\
		w_x = k_x^2 / k^2\n\
		w_y = k_y^2 / k^2\n\
	and perform the inverse fourier transform.\n\
\n\
AUTHOR\n\
	Nick Kaiser:  kaiser@cita.utoronto.ca\n\
\n\n"

#include <stdio.h>
#include <math.h>

#include "../imlib/fits.h"
#include "../utils/arrays.h"
#include "../fftlib/myfft.h"

#define	EPS	1.e-10
#define	PI	M_PI

float	zero(float kx, float ky);
float	invkx(float kx, float ky);
float	invky(float kx, float ky);
float	halfx(float kx, float ky);
float	halfy(float kx, float ky);

int	N1, N2;

main (int argc, char *argv[])
{
	int		arg = 1, mode, i, j;
	float		**fx, **fy, **f, **ffx, **ffy, sumf;
	fitsheader	*fits;
	fft_type 	Fx, Fy;

	/* defaults */

	/* parse args */
	while (arg < argc) {
		if (argv[arg][0] != '-') {
			fprintf(stderr, "%s", usage);
			exit(-1);
		}
		switch (argv[arg++][1]) {
			default:
				fprintf(stderr, "%s", usage);
				exit(-1);
				break;
		}
	}

	/* read the gradient */
	fits = readfitsheader(stdin);
	if (fits->ndim != 3) {
		error_exit("invgrad: input image must be N1 x N2 x 2 dimensional\n");
	}
	N1 = fits->n[0];
	N2 = fits->n[1];
	allocFloatArray(&fx, N1, 2 * N2);
	for (i = 0; i < 2 * N2; i++) {
		readfitsline(fx[i], fits);
	}
	fy = fx + N2;

	/* fix the end row/col */
	for (i = 0; i < N2; i++) {
		sumf = 0.0;
		for (j = 0; j < N1 - 1; j++)
			sumf += fx[i][j];
		fx[i][N1-1] = -sumf;
	}
	for (j = 0; j < N1; j++) {
		sumf = 0.0;
		for (i = 0; i < N2 - 1; i++)
			sumf += fy[i][j];
		fy[N2-1][j] = -sumf;
	}

	allocFloatArray(&f, N1, N2);
	allocFloatArray(&ffx, N1, N2);
	allocFloatArray(&ffy, N1, N2);
	alloc_fft(&Fx, N1, N2);
	alloc_fft(&Fy, N1, N2);

	forward_fft(fx, N1, N2, Fx);
	forward_fft(fy, N1, N2, Fy);

	cfilter(Fx, N1, N2, halfx, invkx);
	cfilter(Fy, N1, N2, halfy, invky);

	inverse_fft(Fx, N1, N2, ffx);
	inverse_fft(Fy, N1, N2, ffy);

	for (i = 0; i < N2; i++) {
		for (j = 0; j < N1; j++) {
			f[i][j] = ffx[i][j] + ffy[i][j];
		}
	}
	
	add_comment(argc, argv, fits);
	fits->ndim = 2;
	write2Dfloatimage(f, fits);
	exit(0);
}


float	zero(float kx, float ky)
{
	return (0.0);
}


float	halfx(float kx, float ky)
{
	int	ikx, iky;
	float	a;
	
	ikx = floor(0.5 + kx * N1 / (2 * PI));
	iky = floor(0.5 + ky * N2 / (2 * PI));
	if (!ikx && !iky)
		return(0.0);

	a = kx * kx / (kx * kx + ky * ky);
	return (-0.5 * a);
}


float	halfy(float kx, float ky)
{
	int	ikx, iky;
	float	a;
	
	ikx = floor(0.5 + kx * N1 / (2 * PI));
	iky = floor(0.5 + ky * N2 / (2 * PI));
	if (!ikx && !iky)
		return(0.0);

	a = ky * ky / (kx * kx + ky * ky);
	return (-0.5 * a);
}


float	invkx(float kx, float ky)
{
	int	ik;
	float	a;

	ik = floor(0.5 + kx * N1 / (2 * PI));
	if (!ik)
		return (0.0);

	a = kx * kx / (kx * kx + ky * ky);
	return (0.5 * a * cos(0.5 * kx) / sin(0.5 * kx));
}


float	invky(float kx, float ky)
{
	int	ik;
	float	a;

	ik = floor(0.5 + ky * N2 / (2 * PI));
	if (!ik)
		return (0.0);

	a = ky * ky / (kx * kx + ky * ky);
	return (0.5 * a * cos(0.5 * ky) / sin(0.5 * ky));
}




#undef EPS



