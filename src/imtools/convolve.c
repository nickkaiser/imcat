#define	usage "\n\n\n\
NAME\n\
	convolve --- convolve one fits file with another\n\
\n\
SYNOPSIS\n\
	convolve [options...] target.fits psf.fits\n\
		-f	# psf.fits contains fft\n\
		-n	# normalise psf\n\
		-m mval	# substitute value for magic target pixels (0.0)\n\
		-d	# don't fix magic pixels\n\
		-o	# psf origin at 0,0.\n\
\n\
DESCRIPTION\n\
	'Convolve' convolves target file 'target.fits' with a\n\
	point spread function 'psf.fits'.  Unlike 'acf -c', the\n\
	two input files need not have the same dimensions (and\n\
	will typically be used with a relatively small psf image)\n\
	but should have the same pixel scale. If the two images\n\
	have the same size then 'acf -c' is more efficient.\n\
	By default 'convolve' expects the psf to be a M1 * M2 real-space\n\
	image with spatial origin at M1 / 2, M2 / 2; use '-o' option\n\
	if the origin is 0, 0. Use -f option to interpret 'psf.fits' as\n\
	a fourier transform of the psf (in format generated by\n\
	'fft'). The output image has the same dimensions and\n\
	type as the input image.\n\
	WARNING - THIS DOES NOT REALLY WORK PROPERLY - TO BE FIXED.\n\
\n\
AUTHOR\n\
	Nick Kaiser:  kaiser@cita.utoronto.ca\n\
\n\n\n"		

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "../imlib/fits.h"
#include "../utils/error.h"
#include "../utils/arrays.h"
#include "../fftlib/myfft.h"

float	rfunc(float kx, float ky);
float	ifunc(float kx, float ky);

static float 	**psffft;
static int	M1, M2;

#define PI M_PI

main(int argc, char *argv[])	
{
	float 		**f, **psf, psffft0, magicval;
	int		arg = 1, N1, N2;
	int		normalise, fixmagic, readfft, cyclepsf;
	int		x, y;
	fitsheader	*fits1, *fits2;
	fft_type	fk, fkpsf;
	FILE		*psffile, *targetfile;
	
	/* defaults */
	normalise = 0;
	magicval = 0.0;
	fixmagic = 1;
	readfft = 0;
	cyclepsf = 1;
	
	while (arg < argc) {
		if (argv[arg][0] != '-')
			break;
		switch (argv[arg++][1]) {
			case 'f':
				readfft = 1;
				break;
			case 'n':
				normalise = 1;
				break;
			case 'd':
				fixmagic = 0;
				break;
			case 'm':
				sscanf(argv[arg++], "%f", &magicval);
				break;
			case 'o':
				cyclepsf = 0;
				break;
			default:
				error_exit(usage);
				break;
		}
	}

	if (arg != argc - 2)
		error_exit(usage);

	targetfile = fopen(argv[arg++], "r");
	psffile = fopen(argv[arg++], "r");
	if (!targetfile || !psffile)
		error_exit("convolve: unable to open input file\n");

	read2Dfloatimage(&f, &N1, &N2, &fits1, targetfile);
	if (fixmagic) {
		substitute(f, N1, N2, magicval);
	}

	if (readfft) {
		read2Dfloatimage(&psffft, &M1, &M2, &fits2, psffile);
		M2 /= 2;
	} else {
		read2Dfloatimage(&psf, &M1, &M2, &fits2, psffile);
		if (cyclepsf)
			cycleimage(psf, M1, M2, M1 / 2, M2 / 2);
		alloc_fft(&fkpsf, M1, M2);
		forward_fft(psf, M1, M2, fkpsf);
		allocFloatArray(&psffft, M1, 2 * M2);
		get_fft(fkpsf, M1, M2, psffft);
	}

	if (normalise) {
		psffft0 = psffft[M2 / 2][M1 / 2];
		if (psffft0 <= 0.0)
			error_exit("convolve: can't normalise: non-negative zero frequency psf\n");
		for (y = 0; y < 2 * M2; y++) {
			for (x = 0; x < M1; x++) {
				psffft[y][x] /= psffft0;
			}
		}
	}


	alloc_fft(&fk, N1, N2);
	forward_fft(f, N1, N2, fk);
	cfilter(fk, N1, N2, rfunc, ifunc);
	inverse_fft(fk, N1, N2, f);
	add_comment(argc, argv, fits1);
	write2Dfloatimage(f, fits1);
	exit(0);
}






float	rfunc(float kx, float ky)
{
	int	ix, iy;

	ix = M1 / 2 + floor(0.5 + M1 * kx / (2 * PI));
	iy = M2 / 2 + floor(0.5 + M2 * ky / (2 * PI));
	if (ix < 0 || ix >= M1 || iy < 0 || iy >= M2) {
		return(0.0);
	} else {
		return(psffft[iy][ix]);
	}
}


float	ifunc(float kx, float ky)
{
	int	ix, iy;

	ix = M1 / 2 + floor(0.5 + M1 * kx / (2 * PI));
	iy = M2 / 2 + floor(0.5 + M2 * ky / (2 * PI));
	if (ix < 0 || ix >= M1 || iy < 0 || iy >= M2) {
		return(0.0);
	} else {
		return(psffft[M2 + iy][ix]);
	}
}





