#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "vectors.h"
#include "Ffunc.h"
#include "utils/gaussdev.h"
#include "tcl.h"

#define usage "\nNAME\n\
	chisquare\n\
\n\
SYNOPSIS\n\
	chisquare obscat\n\
\n\
DESCRIPTION\n\
	chisquare finds a minimum chi-squared solution for a set of three observations\n\
	given a starting point (possible generated by laplace3).\n\
\n\
	It does this by generating a cloud of phase-points x[6] around the initial\n\
	solution and computes, for each point a chi-squared and then fits this\n\
	to a second order polynomial in dx[6].  The ML solution and the curvature\n\
	matrix are then read off the resulting output file.\n\
\n\
	chisquare reads an lc format catalog from stdin containing the\n\
	a preliminary solution ra[3], va[3] and an estimate of the uncertainty\n\
	in the distance, sigmad and d.  These are generated by laplace3.\n\
\n\
	It then reads a set of observations from obscat, and for each phase-point\n\
	computes the chi-squared statistic.\n\
\n\
SEE ALSO\n\
	makeobs_inertial makeobs_circ laplace3 tcl_evolve r2n chisquare\n\
AUTHOR\n\
	Nick Kaiser --- kaiser@hawaii.edu\n\n"


main (int argc, char *argv[])
{
	/* input values */
	double	d, sigmad, *r0, *v0, *ra, *va, **dr, **dv, **r, **v, *t, *sigma, *n, **re, **rho, **nobs;
	double	tau, dt, chi2, Mdet, Pdet, theta, phi, *iota[2], **C, *tmpvec;
	int	i, j, it, nt, ip, np, niter, *indx, alpha, beta;
	/* a, b label 6-vectors */
	int	a, b, c;
	/* coefficients of the fit to chi^2 */
	double	chi0, *chi_a, **M, **Minv, *p, *dx, **tmp, xfactor, gdevr, gdevv, **P;
	/* I/O stuff */
	FILE	*ipf, *obscatf, *opf;
	char	*obscatfilename, lccom[1024];

	/* parse args */
	if (argc != 2) {
		fprintf(stderr, usage);
		exit(-1);
	}
	obscatfilename = argv[1];

	/* number of observations */
	nt = 3;

	/* number of phase points */
	np = 100;
	/* scale phase point displacements by this factor */
	xfactor = 0.1;

	/* allocate the initial solution */
	r0 = (double *) calloc(3, sizeof(double));
	v0 = (double *) calloc(3, sizeof(double));
	/* and the internal arrays */
	ra = (double *) calloc(3, sizeof(double));
	va = (double *) calloc(3, sizeof(double));
	n  = (double *) calloc(3, sizeof(double));

	/* basis vectors 
	iota[0]  = (double *) calloc(3, sizeof(double));
	iota[1]  = (double *) calloc(3, sizeof(double));

	/* C-matrix */
	C = (double **) calloc(2, sizeof(double *));
	for (alpha = 0; alpha < 2; alpha++) {
		C[alpha] = (double *) calloc(2, sizeof(double));
	}

	/* allocate the cloud of phase-points */
	dr = (double **) calloc(np, sizeof(double *));
	dv = (double **) calloc(np, sizeof(double *));
	r = (double **) calloc(np, sizeof(double *));
	v = (double **) calloc(np, sizeof(double *));
	for (ip = 0; ip < np; ip++) {
		dr[ip] = (double *) calloc(3, sizeof(double));
		dv[ip] = (double *) calloc(3, sizeof(double));
		r[ip] = (double *) calloc(3, sizeof(double));
		v[ip] = (double *) calloc(3, sizeof(double));
	}

	/* allocate observation data */
	t = (double *) calloc(nt, sizeof(double));
	sigma = (double *) calloc(nt, sizeof(double));
	re = (double **) calloc(nt, sizeof(double *));
	rho = (double **) calloc(nt, sizeof(double *));
	nobs = (double **) calloc(nt, sizeof(double *));
	for (it = 0; it < nt; it++) {
		re[it] = (double *) calloc(nt, sizeof(double));
		rho[it] = (double *) calloc(nt, sizeof(double));
		nobs[it] = (double *) calloc(nt, sizeof(double));
	}

	/* allocate the indices p[6], and the array chi_a and matrix chi_ab */
	p = (double *) calloc(6, sizeof(double));
	dx = (double *) calloc(6, sizeof(double));
	tmpvec = (double *) calloc(6, sizeof(double));
	chi_a = (double *) calloc(6, sizeof(double));
	M = (double **) calloc(6, sizeof(double *));
	Minv = (double **) calloc(6, sizeof(double *));
	tmp = (double **) calloc(6, sizeof(double *));
	P = (double **) calloc(6, sizeof(double *));
	indx = (int *) calloc(6, sizeof(int));
	for (a = 0; a < 6; a++) {
		M[a] = (double *) calloc(6, sizeof(double));
		Minv[a] = (double *) calloc(6, sizeof(double));
		tmp[a] = (double *) calloc(6, sizeof(double));
		P[a] = (double *) calloc(6, sizeof(double));
	}

	/* open the pipe for the initial solution */
	ipf = popen("lc -b -o d sigmad ra va", "r");
	if (!ipf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe for input\n");
		exit(-1);
	}

	/* read the initial solution */
	fread(&d, sizeof(double), 1, ipf);
	fread(&sigmad, sizeof(double), 1, ipf);
	fread(r0, sizeof(double), 3, ipf);
	fread(v0, sizeof(double), 3, ipf);
	pclose(ipf);

	/* open the pipe for the observations */
	sprintf(lccom, "lc -b -o t sigma re rho n < %s", obscatfilename);
	obscatf = popen(lccom, "r");
	if (!obscatf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe for obscat\n");
		exit(-1);
	}

	/* read the observation data */
	for (it = 0; it < nt; it++) {
		fread(t + it, sizeof(double), 1, ipf);
		fread(sigma + it, sizeof(double), 1, ipf);
		fread(re[it], sizeof(double), 3, ipf);
		fread(rho[it], sizeof(double), 3, ipf);
		fread(nobs[it], sizeof(double), 3, ipf);
	}
	pclose(ipf);
	dt = t[2];

	/* generate a cloud of phase point deviations*/
	for (ip = 0; ip < np; ip++) {
		/* compute an error ~sigma * d for r[] and ~ sigma * d / dt for v[]*/
		for (i = 0; i < 3; i++) {
			dr[ip][i] = d * sigma[1] * gaussdev();
			dv[ip][i] = d * sigma[1] * gaussdev() / dt;
		}
		/* add big error to the radial components */
		gdevr = gaussdev();
		gdevv = gaussdev();
		for (i = 0; i < 3; i++) {
			dr[ip][i] += sigmad * (r0[i] - re[1][i] - rho[1][i]) * gdevr / d;
			dv[ip][i] += sigmad * (r0[i] - re[1][i] - rho[1][i]) * gdevv / d;
			dr[ip][i] *= xfactor;
			dv[ip][i] *= xfactor;
		}
	}

	niter = 4;
	while (niter--) {
	/* output the catalog of phase points */
	opf = popen("lc -C -N '1 6 dx' -n chi2 > tmp.chi2.cat", "w");
	if (!opf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe for output\n");
		exit(-1);
	}
	for (ip = 0; ip < np; ip++) {
		chi2 = 0.0;
		for (it = 0; it < nt; it++) {
			for (i = 0; i < 3; i++) {
				ra[i] = r0[i] + dr[ip][i];
				va[i] = v0[i] + dv[ip][i];
			}
			if (it != 1) {
				/* evolve the phase-space coordinates */
				tcl(t[it] / 10.0, 10, ra, va);
			}
			/* compute the direction */
			for (i = 0; i < 3; i++) {
				n[i] = ra[i] - re[it][i] - rho[it][i];
			}
			scale(n, 1.0 / length(n));
			for (i = 0; i < 3; i++) {
				chi2 += (nobs[it][i] - n[i]) * (nobs[it][i] - n[i]) / (sigma[it] * sigma[it]);
			}
		}
		fprintvec(dr[ip], opf);
		fprintvec(dv[ip], opf);
		fprintf(opf, "%14.8lg\n", chi2);
	}
	pclose(opf);

	/* get the coefficients of a polynomial fit to chi2(delta x) */
	ipf = popen("fitlmodel dx chi2 -p 0 2 < tmp.chi2.cat | lc -b -o p chi2 ", "r");
	if (!ipf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe to input tmp.chi2.cat\n");
		exit(-1);
	}

	/* the first line is the constant value chi0 */
	fread(p, sizeof(double), 6, ipf);
	fread(&chi0, sizeof(double), 1, ipf);
	/* the next six lines are the linear terms */
	for (i = 0; i < 6; i++) {
		fread(p, sizeof(double), 6, ipf);
		for (c = 0; c < 6; c++) {
			if ((int) (p[c])) {
				a = c;
			}
		}
		fread(chi_a + a, sizeof(double), 1, ipf);
	}
	/* the next 21 lines are the quadratic terms */
	/* this is a little tricky because, for the non-diagonal terms, the */
	/* coefficient is d^2 chi^2 / d x_a d x_b wherease for the diagonal */
	/* terms the coefficient is (1/2) d^2 chi^2 / d x_a^2 */
	/* the matrix Minv[a][b] here contains (1/2) d^2 chi^2 / d x_a d x_b */
	/* which is the curvature matrix (minus 2nd derivative of the likelihood */
	for (i = 0; i < 21; i++) {
		fread(p, sizeof(double), 6, ipf);
		a = -1;
		for (c = 0; c < 6; c++) {
			if ((int) (p[c]) == 2) {
				a = b = c;
			}
			if ((int) (p[c]) == 1) {
				if (a >= 0) {	/* we already have a */
					b = c;
				} else {
					a = c;
				}
			}
		}
		fread(Minv[a] + b, sizeof(double), 1, ipf);
		if (a != b) {
			Minv[a][b] *= 0.5;
			Minv[b][a] = Minv[a][b];
		}
	}
	pclose(ipf);

	/* compute the covariance matrix M[][] */
	invertmatrix(Minv, M, 6);

	/* compute the correction to the phase-space coords */
	for (a = 0; a < 6; a++) {
		dx[a] = 0;
		for (b = 0; b < 6; b++) {
			dx[a] -= 0.5 * M[a][b] * chi_a[b];
		}
	}

	for (i = 0; i < 3; i++) {
		r0[i] += dx[i];
		v0[i] += dx[3 + i];
	}

	fprintf(stderr, "chi0=%14.8lg\n", chi0);

	/* compute the determinant */
	/* make a copy of M */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = M[a][b];
		}
	}
	myludcmp(tmp, 6, indx, &Mdet);
	for (a = 0; a < 6; a++) {
		Mdet *= tmp[a][a];
	}
	fprintf(stderr, "Mdet=%14.8lg\n", Mdet);


	}		

	/* check inverse */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
				tmp[a][b] = 0.0;
				for (c = 0; c < 6; c++) {
					tmp[a][b] += Minv[a][c] * M[c][b];
				}
		}
	}

	fprintf(stderr, "chi0=%14.8lg\n\n", chi0);
	for (a = 0; a < 6; a++) {
		fprintf(stderr, "%14.8lg ", chi_a[a]);
	}
	fprintf(stderr, "\n\n");
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			fprintf(stderr, "%14.8lg ", Minv[a][b]);
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "\n");

	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			fprintf(stderr, "%14.8lg ", M[a][b]);
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "\n");

	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			fprintf(stderr, "%14.8lg ", tmp[a][b]);
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "\n");

	for (a = 0; a < 6; a++) {
		fprintf(stderr, "%14.8lg ", dx[a]);
	}
	fprintf(stderr, "\n\n");

	printvec(r0, "ra");
	printvec(v0, "va");

	/* now let's propagate to time t=tau */
	tau = 0.5;
	for (ip = 0; ip < np; ip++) {
		for (i = 0; i < 3; i++) {
			r[ip][i] = r0[i] + dr[ip][i];
			v[ip][i] = v0[i] + dv[ip][i];
		}
		/* evolve the phase-space coordinates */
		tcl(tau / 100.0, 100, r[ip], v[ip]);
	}
	/* and evolve r0, v0 */
	tcl(tau / 100.0, 100, r0, v0);
	/* fit a linear model for dxt =  */
	opf = popen("lc -C -N '1 6 dx0' -N '1 6 dxt' | fitlmodel dx0 dxt -p 1 1 > tmp.P.par", "w");
	if (!opf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe for output\n");
		exit(-1);
	}
	for (ip = 0; ip < np; ip++) {
		for (i = 0; i < 3; i++) {
			r[ip][i] -= r0[i];
			v[ip][i] -= v0[i];
		}
		fprintvec(dr[ip], opf);
		fprintvec(dv[ip], opf);
		fprintvec(r[ip], opf);
		fprintvec(v[ip], opf);
	}
	pclose(opf);
	/* the file tmp.P.par now contains the lines of P[][] (in reverse order) */
	ipf = popen("lc -b -o dxt < tmp.P.par", "r");
	if (!ipf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe to input tmp.chi2.cat\n");
		exit(-1);
	}
	for (a = 5; a >= 0; a--) {
		fread(P[a], sizeof(double), 6, ipf);
	}	
	pclose(ipf);

	/* compute the determinant of P */
	/* make a copy of P */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = P[a][b];
		}
	}
	myludcmp(tmp, 6, indx, &Pdet);
	for (a = 0; a < 6; a++) {
		Pdet *= tmp[a][a];
	}
	fprintf(stderr, "\nPdet=%14.8lg\n\n", Pdet);

	/* update the curvature matrix */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = 0.0;
			for (c = 0; c < 6; c++) {
				tmp[a][b] += Minv[a][c] * P[b][c];
			}
		}
	}
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			Minv[a][b] = 0.0;
			for (c = 0; c < 6; c++) {
				Minv[a][b] += P[a][c] * tmp[c][b];
			}
		}
	}

	/* compute the covariance matrix M[][] */
	invertmatrix(Minv, M, 6);

	/* and write it out */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			fprintf(stderr, "%14.8lg ", M[a][b]);
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "\n");

	/* compute the determinant of M */
	/* make a copy of M */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = M[a][b];
		}
	}
	myludcmp(tmp, 6, indx, &Mdet);
	for (a = 0; a < 6; a++) {
		Mdet *= tmp[a][a];
	}
	fprintf(stderr, "Mdet=%14.8lg\n\n", Mdet);

	/* compute the basis vectors */
	theta = acos(r0[2]);
	phi = atan2(r0[1], r0[0]);
        assign(iota[0], - sin(phi), cos(phi), 0.0);
        assign(iota[1], cos(theta) * cos(phi), cos(theta) * sin(phi), - sin(theta));

	/* compute C[2][2] */
	for (alpha = 0; alpha < 2; alpha++) {
		for (beta = 0; beta < 2; beta++) {
			for (i = 0; i < 3; i++) {
				tmpvec[i] = 0.0;
				for (j = 0; j < 3; j++) {
					tmpvec[i] += M[i][j] * iota[alpha][j];
				}
			}
			C[alpha][beta] = 0.0;
			for (i = 0; i < 3; i++) {
				C[alpha][beta] += iota[beta][i] * tmpvec[i];
			}
			fprintf(stderr, "%14.8lg ", C[alpha][beta]);
		}
		fprintf(stderr, "\n");
	}

	fprintf(stderr, "\nsqrt(det(C))=%14.8lg\n", sqrt(fabs(C[0][0] * C[1][1] - C[0][1] * C[1][0])));

	/* now compute the curvature after we make an obs */
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			for (alpha = 0; alpha < 2; alpha++) {
				Minv[i][j] += iota[alpha][i] * iota[alpha][j] /  (d * d * 2.5e-13);
			}
		}
	}

	/* compute the covariance matrix M[][] */
	invertmatrix(Minv, M, 6);

	/* compute the determinant of M */
	/* make a copy of M */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = M[a][b];
		}
	}
	myludcmp(tmp, 6, indx, &Mdet);
	for (a = 0; a < 6; a++) {
		Mdet *= tmp[a][a];
	}
	fprintf(stderr, "Mdet=%14.8lg\n\n", Mdet);


	exit(0);
}

