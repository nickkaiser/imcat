#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "vectors.h"
#include "Ffunc.h"
#include "utils/gaussdev.h"
#include "tcl.h"

#define usage "\nNAME\n\
	leastsquares\n\
\n\
SYNOPSIS\n\
	leastsquares obscat t nsteps xfactor\n\
\n\
DESCRIPTION\n\
	leastsquares finds a minimum chi-squared solution for a set of observations\n\
	given a starting point (possible generated by laplace3).\n\
\n\
	leastsquares reads an lc format catalog from stdin containing the\n\
	a preliminary solution ra[3], va[3] and an estimate of the uncertainty\n\
	in the distance, sigmad and d.  These are generated by laplace3.\n\
\n\
	It then reads a set of observations from obscat, and finds a minimum\n\
	chi^2 by dynamically propagating a set of points.\n\
\n\
SEE ALSO\n\
	makeobs_inertial makeobs_circ laplace3 tcl_evolve r2n leastsquares\n\
AUTHOR\n\
	Nick Kaiser --- kaiser@hawaii.edu\n\n"

/* globals */
double	**re, **rho, **nobs, **dnobs, *n, *t, *sigma, *ra, *va, **tmp;
double	*iota[2], **M, *tmpvec, **C, arcsec, *n0;
int	nt, *indx;
/* powell stuff */
double	**powell_xi, powell_ftol, powell_fret;

double	chisquared(double *x);
void powell(double p[], double **xi, int n, double ftol, int *iter, double *fret,
        double (*func)(double []));
void	getbasis(double *n, double *i0, double *i1);
double	det(double **M, int n);
void	getC(void);
void	printmatrix(double **m, int n, char *tag);
void	findmin(double *r0, double *v0, double *x);

main (int argc, char *argv[])
{
	/* input values */
	double	d, sigmad, *r0, *v0, **dr, **dv, **r, **v;
	double	tau, dt, chi2, chi2min, Mdet, Pdet;
	int	i, j, it, ip, np, alpha, beta, nsteps;
	/* a, b label 6-vectors */
	int	a, b, c;
	/* coefficients of the fit to chi^2 */
	double	chi0, *chi_a, **Minv, *p, *dx, *x, xfactor, gdev, gdevr, gdevv, **P;
	/* I/O stuff */
	FILE	*ipf, *obscatf, *opf;
	char	*obscatfilename, lccom[1024];

	/* parse args */
	if (argc != 5) {
		fprintf(stderr, usage);
		exit(-1);
	}
	obscatfilename = argv[1];
	if ((1 != sscanf(argv[2], "%lf", &tau)) || (1 != sscanf(argv[3], "%d", &nsteps))|| (1 != sscanf(argv[4], "%lf", &xfactor))) {
		fprintf(stderr, usage);
		exit(-1);
	}

	/* number of observations */
	nt = 3;

	/* number of phase points */
	np = 100;

	/* arc-second in radians */
	arcsec = M_PI / (180.0 * 3600.0);

	/* allocate the initial solution */
	r0 = (double *) calloc(3, sizeof(double));
	v0 = (double *) calloc(3, sizeof(double));
	/* and the internal arrays */
	ra = (double *) calloc(3, sizeof(double));
	va = (double *) calloc(3, sizeof(double));
	n  = (double *) calloc(3, sizeof(double));

	/* basis vectors */
	n0  = (double *) calloc(3, sizeof(double));
	iota[0]  = (double *) calloc(3, sizeof(double));
	iota[1]  = (double *) calloc(3, sizeof(double));

	/* C-matrix */
	C = (double **) calloc(2, sizeof(double *));
	for (alpha = 0; alpha < 2; alpha++) {
		C[alpha] = (double *) calloc(2, sizeof(double));
	}

	/* allocate the cloud of phase-points */
	dr = (double **) calloc(np, sizeof(double *));
	dv = (double **) calloc(np, sizeof(double *));
	r = (double **) calloc(np, sizeof(double *));
	v = (double **) calloc(np, sizeof(double *));
	for (ip = 0; ip < np; ip++) {
		dr[ip] = (double *) calloc(3, sizeof(double));
		dv[ip] = (double *) calloc(3, sizeof(double));
		r[ip] = (double *) calloc(3, sizeof(double));
		v[ip] = (double *) calloc(3, sizeof(double));
	}

	/* allocate observation data */
	t = (double *) calloc(nt, sizeof(double));
	sigma = (double *) calloc(nt, sizeof(double));
	re = (double **) calloc(nt, sizeof(double *));
	rho = (double **) calloc(nt, sizeof(double *));
	nobs = (double **) calloc(nt, sizeof(double *));
	dnobs = (double **) calloc(nt, sizeof(double *));
	for (it = 0; it < nt; it++) {
		re[it] = (double *) calloc(nt, sizeof(double));
		rho[it] = (double *) calloc(nt, sizeof(double));
		nobs[it] = (double *) calloc(nt, sizeof(double));
		dnobs[it] = (double *) calloc(nt, sizeof(double));
	}

	/* allocate the indices p[6], and the array chi_a and matrix chi_ab */
	p = (double *) calloc(6, sizeof(double));
	x = (double *) calloc(6, sizeof(double));
	dx = (double *) calloc(6, sizeof(double));
	tmpvec = (double *) calloc(6, sizeof(double));
	chi_a = (double *) calloc(6, sizeof(double));
	M = (double **) calloc(6, sizeof(double *));
	Minv = (double **) calloc(6, sizeof(double *));
	tmp = (double **) calloc(6, sizeof(double *));
	powell_xi = (double **) calloc(6, sizeof(double *));
	P = (double **) calloc(6, sizeof(double *));
	indx = (int *) calloc(6, sizeof(int));
	for (a = 0; a < 6; a++) {
		M[a] = (double *) calloc(6, sizeof(double));
		Minv[a] = (double *) calloc(6, sizeof(double));
		tmp[a] = (double *) calloc(6, sizeof(double));
		powell_xi[a] = (double *) calloc(6, sizeof(double));
		P[a] = (double *) calloc(6, sizeof(double));
	}

	/* open the pipe for the initial solution */
	ipf = popen("lc -b -o d sigmad ra va", "r");
	if (!ipf) {
		fprintf(stderr, "leastsquares : failed to open lc-pipe for input\n");
		exit(-1);
	}

	/* read the initial solution */
	fread(&d, sizeof(double), 1, ipf);
	fread(&sigmad, sizeof(double), 1, ipf);
	fread(r0, sizeof(double), 3, ipf);
	fread(v0, sizeof(double), 3, ipf);
	pclose(ipf);

	/* open the pipe for the observations */
	sprintf(lccom, "lc -b -o t sigma re rho n < %s", obscatfilename);
	ipf = popen(lccom, "r");
	if (!ipf) {
		fprintf(stderr, "leastsquares : failed to open lc-pipe for obscat\n");
		exit(-1);
	}

	/* read the observation data */
	for (it = 0; it < nt; it++) {
		fread(t + it, sizeof(double), 1, ipf);
		fread(sigma + it, sizeof(double), 1, ipf);
		fread(re[it], sizeof(double), 3, ipf);
		fread(rho[it], sizeof(double), 3, ipf);
		fread(nobs[it], sizeof(double), 3, ipf);
	}
	pclose(ipf);
	dt = t[2];

	/* compute the basis vectors n0, iota[01] */
	for (i = 0; i < 3; i++) {
		n0[i] = r0[i] - re[1][i] - rho[1][i];
	}
	scale(n0, 1.0 / length(n0));
	getbasis(n0, iota[0], iota[1]);

	/* find the minimum of chi^2 */
	findmin(r0, v0, x);
	chi2min = chisquared(x);

	/* copy the least-squares solution to r0[], v0[] */
	copy(r0, x);
	copy(v0, x + 3);
	fprintf(stderr, "# least squares solution\n");
	printvec(r0, "r");
	printvec(v0, "v");
	fprintf(stderr, "chi2min=%14.8lg\n\n", chi2min);

	/* generate a cloud of phase points around (r0, v0) */
	for (ip = 0; ip < np; ip++) {
		/* generate some observational errors */
		for (it = 0; it < nt; it++) {
			for (i = 0; i < 3; i++) {
					dnobs[it][i] = 0.0;
			}
			for (alpha = 0; alpha < 2; alpha++) {
				gdev = xfactor * sigma[it] * gaussdev();
				for (i = 0; i < 3; i++) {
					dnobs[it][i] += gdev * iota[alpha][i];
				}
			}
		}
		/* find the perturbed minimum */
		findmin(r0, v0, x);
		copy(r[ip], x);
		copy(v[ip], x + 3);
		diff(dr[ip], r[ip], r0);
		diff(dv[ip], v[ip], v0);
	}
	/* and zero the perturbing errors */
	for (it = 0; it < nt; it++) {
		for (i = 0; i < 3; i++) {
				dnobs[it][i] = 0.0;
		}
	}

	/* compute the approximate covariance matrix M[][] */
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			M[i][j] = M[i][j + 3] = M[i + 3][j] = M[i + 3][j + 3] = 0.0;
			for (ip = 0; ip < np; ip++) {
				M[i][j] += dr[ip][i] * dr[ip][j];
				M[i][j + 3] += dr[ip][i] * dv[ip][j];
				M[i + 3][j] += dv[ip][i] * dr[ip][j];
				M[i + 3][j + 3] += dv[ip][i] * dv[ip][j];
			}
		}
	}
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			M[a][b] /= np * xfactor * xfactor;
		}
	}

	printmatrix(M, 6, "M[][]");

if (0) {
	/* fit for chi2 = chi2min  */
	opf = popen("lc -C -b -N '1 6 dx' -n chi2 > tmp.chi2.cat", "w");
	if (!opf) {
		fprintf(stderr, "leastsquares : failed to open lc-pipe for output\n");
		exit(-1);
	}
	for (ip = 0; ip < np; ip++) {
		copy(x, r[ip]);
		copy(x + 3, v[ip]);
		fprintvec(dr[ip], opf);
		fprintvec(dv[ip], opf);
		fprintf(opf, "%14.10lg\n", chisquared(x) - chi2min);
	}
	pclose(opf);

	/* get the coefficients of a polynomial fit to chi2(delta x) */
	ipf = popen("fitlmodel dx chi2 -p 2 2 < tmp.chi2.cat | lc -b -o p chi2", "r");
	if (!ipf) {
		fprintf(stderr, "chisquare : failed to open lc-pipe to input tmp.chi2.cat\n");
		exit(-1);
	}
	/* for the non-diagonal terms, the */
	/* coefficient is d^2 chi^2 / d x_a d x_b wherease for the diagonal */
	/* terms the coefficient is (1/2) d^2 chi^2 / d x_a^2 */
	/* the matrix Minv[a][b] here contains (1/2) d^2 chi^2 / d x_a d x_b */
	/* which is the curvature matrix (minus 2nd derivative of the likelihood */
	for (i = 0; i < 21; i++) {
		fread(p, sizeof(double), 6, ipf);
		a = -1;
		for (c = 0; c < 6; c++) {
			if ((int) (p[c]) == 2) {
				a = b = c;
			}
			if ((int) (p[c]) == 1) {
				if (a >= 0) {	/* we already have a */
					b = c;
				} else {
					a = c;
				}
			}
		}
		fread(Minv[a] + b, sizeof(double), 1, ipf);
		if (a != b) {
			Minv[a][b] *= 0.5;
			Minv[b][a] = Minv[a][b];
		}
	}
	pclose(ipf);

}

	/* compute the determinant */
	Mdet = det(M, 6);
	fprintf(stderr, "Mdet=%14.8lg\n", Mdet);

	/* compute the C matrix */
	getC();
	printmatrix(C, 2, "C[][]");

	/* compute the inverse covariance matrix Minv[][] */
	invertmatrix(M, Minv, 6);

	/* now let's propagate to time t=tau */
	for (ip = 0; ip < np; ip++) {
		for (i = 0; i < 3; i++) {
			r[ip][i] = r0[i] + dr[ip][i];
			v[ip][i] = v0[i] + dv[ip][i];
		}
		/* evolve the phase-space coordinates */
		tcl(tau / nsteps, nsteps, r[ip], v[ip]);
	}
	/* and evolve r0, v0 */
	tcl(tau / nsteps, nsteps, r0, v0);
	/* fit a linear model for dx0_a = P_ab dxt_b */
	opf = popen("lc -C -b -N '1 6 dx0' -N '1 6 dxt' > tmp.P.cat", "w");
	if (!opf) {
		fprintf(stderr, "leastsquares : failed to open lc-pipe for output\n");
		exit(-1);
	}
	for (ip = 0; ip < np; ip++) {
		for (i = 0; i < 3; i++) {
			r[ip][i] -= r0[i];
			v[ip][i] -= v0[i];
		}
		fprintvec(dr[ip], opf);
		fprintvec(dv[ip], opf);
		fprintvec(r[ip], opf);
		fprintvec(v[ip], opf);
	}
	pclose(opf);
	/* the file tmp.P.par now contains the lines of P[][] (in reverse order) */
	ipf = popen("fitlmodel dxt dx0 -p 1 1 < tmp.P.cat | lc -b -o dx0", "r");
	if (!ipf) {
		fprintf(stderr, "leastsquares : failed to open lc-pipe to input tmp.chi2.cat\n");
		exit(-1);
	}
	for (a = 5; a >= 0; a--) {
		fread(P[a], sizeof(double), 6, ipf);
	}	
	pclose(ipf);

	/* compute the determinant of P */
	Pdet = det(P, 6);
	fprintf(stderr, "\nPdet=%14.8lg\n\n", Pdet);

	/* transform the curvature matrix */
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			tmp[a][b] = 0.0;
			for (c = 0; c < 6; c++) {
				tmp[a][b] += Minv[a][c] * P[c][b];
			}
		}
	}
	for (a = 0; a < 6; a++) {
		for (b = 0; b < 6; b++) {
			Minv[a][b] = 0.0;
			for (c = 0; c < 6; c++) {
				Minv[a][b] += P[c][a] * tmp[c][b];
			}
		}
	}

	/* compute the covariance matrix M[][] */
	invertmatrix(Minv, M, 6);

	/* compute the determinant of M */
	Mdet = det(M, 6);
	fprintf(stderr, "Mdet=%14.8lg\n\n", Mdet);

	/* compute the basis vectors */
	copy(n0, r0);
	scale(n0, 1.0 / length(n0));
	getbasis(n0, iota[0], iota[1]);

	/* compute C[2][2] */
	getC();
	printmatrix(C, 2, "C[][]");

	fprintf(stderr, "\nsqrt(det(C))=%14.8lg\n", sqrt(fabs(C[0][0] * C[1][1] - C[0][1] * C[1][0])));

	/* now compute the curvature after we make an obs */
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			for (alpha = 0; alpha < 2; alpha++) {
				Minv[i][j] += iota[alpha][i] * iota[alpha][j] /  (d * d * sigma[1] * sigma[1]);
			}
		}
	}

	/* compute the covariance matrix M[][] */
	invertmatrix(Minv, M, 6);

	/* compute the determinant of M */
	Mdet = det(M, 6);
	fprintf(stderr, "Mdet=%14.8lg\n\n", Mdet);


	exit(0);
}


double	chisquared(double *x)
{
	int	i, it, ns;
	double	chi2, dn;

	ns = 3;
	chi2 = 0.0;
	for (it = 0; it < nt; it++) {
		for (i = 0; i < 3; i++) {
			ra[i] = x[i];
			va[i] = x[3 + i];
		}
		if (it != 1) {
			/* evolve the phase-space coordinates */
				tcl(t[it] / ns, ns, ra, va);
		}
		for (i = 0; i < 3; i++) {
			n[i] = ra[i] - re[it][i] - rho[it][i];
		}
		scale(n, 1.0 / length(n));
		for (i = 0; i < 3; i++) {
			dn = nobs[it][i] + dnobs[it][i] - n[i];
			chi2 += dn * dn / (sigma[it] * sigma[it]);
		}

	}
	return(chi2);
}


void	getbasis(double *n, double *i0, double *i1)
{
	double	theta, phi;

	theta = acos(n[2]);
	phi = atan2(n[1], n[0]);
        assign(i0, - sin(phi), cos(phi), 0.0);
        assign(i1, cos(theta) * cos(phi), cos(theta) * sin(phi), - sin(theta));
}

double	det(double **M, int n)
{
	int	a, b;
	double	Mdet;

	/* make a copy of M */
	for (a = 0; a < n; a++) {
		for (b = 0; b < n; b++) {
			tmp[a][b] = M[a][b];
		}
	}
	myludcmp(tmp, n, indx, &Mdet);
	for (a = 0; a < n; a++) {
		Mdet *= tmp[a][a];
	}
	return(Mdet);
}

void	getC(void) 
{
	int	alpha, beta, i, j;

	for (alpha = 0; alpha < 2; alpha++) {
		for (beta = 0; beta < 2; beta++) {
			for (i = 0; i < 3; i++) {
				tmpvec[i] = 0.0;
				for (j = 0; j < 3; j++) {
					tmpvec[i] += M[i][j] * iota[alpha][j];
				}
			}
			C[alpha][beta] = 0.0;
			for (i = 0; i < 3; i++) {
				C[alpha][beta] += iota[beta][i] * tmpvec[i];
			}
			C[alpha][beta] /= arcsec * arcsec;
		}
	}
}

void	printmatrix(double **m, int n, char *tag)
{
	int	a, b;

	fprintf(stdout, "%s=\n", tag);
	for (a = 0; a < n; a++) {
		for (b = 0; b < n; b++) {
			fprintf(stdout, "%14.8lg ", m[a][b]);
		}
		fprintf(stdout, "\n");
	}
	fprintf(stdout, "\n");
}

void	findmin(double *r0, double *v0, double *x)
{
	int	powell_iter, i;

	/* create the directions and initial position for powell */
	for (i = 0; i < 3; i++) {
		powell_xi[0][i] = n0[i];
		powell_xi[1][i] = iota[0][i];
		powell_xi[2][i] = iota[1][i];
		powell_xi[3][3 + i] = n0[i];
		powell_xi[4][3 + i] = iota[0][i];
		powell_xi[5][3 + i] = iota[1][i];
		x[i] = r0[i];
		x[3 + i] = v0[i];
	}
	
	/* run powell to find the minimum chi^2 */
	powell_ftol = 1.e-20;
	powell(x, powell_xi, 6, powell_ftol, &powell_iter, &powell_fret, chisquared);
}

