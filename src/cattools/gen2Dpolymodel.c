/*
 * gen2Dpolymodel.c
 */


#define	usage "\n\n\n\
NAME\n\
	gen2Dpolymodel --- generate 2D spatial polynomial model\n\
\n\
SYNOPSIS\n\
	gen2Dpolymodel parfile [options...]\n\
		-x xname	# specify spatial coordinate name\n\
		-s suffix 	# suffix for model values ('mod')\n\
\n\
DESCRIPTION\n\
	'gen2Dpolymodel' reads a catalogue from stdin, and a parameter\n\
	file generated by 'fit2Dpolymodel' from 'parfile' and sends to\n\
	stdout a catalogue containing all the items from the stdin cat\n\
	plus an extra item consisting of the fitted model values:\n\
	By default the name of the spatial variable is taken from the\n\
	header of the 'parfile', but you can override this with the -x\n\
	option.  By default the name of the new item is inherited from\n\
	the names of the model coefficient item in the 'parfile' with\n\
	the addition of the suffix 'mod', but you can change this with\n\
	the -s option.\n\
\n\
AUTHOR\n\
	Nick Kaiser --- kaiser@ifa.hawaii.edu\n\
\n\n\n"		


#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include "../catlib/cat.h"					/* READ THIS! */
#include "../utils/error.h"
#include "../utils/modefunc.h"

static	double		**var;
static	int		varind;
void	getaddresses(void *addr, int ndim, int *dim);

main(int argc, char *argv[])	
{
	int		arg = 2;
	char		*parfilename, *xname, *parfilexname, varname[128], *suffix, defsuffix[4] = "mod";
	cathead		*inputcathead, *outputcathead;		/* catalogue stuff... */
	object		*inputobject, *outputobject;
	item		*modelvalitem;			/* new items we create here... */
	int		imodelval;			/* we'll want their indices... */
	void		*modelval;			/* and local handles */
	double		*x;				/* handles for input variables we want */
	char		*vardef[MODEFUNC_MAX_VARS];
	int		*l, *m, mode, nmodes, nvar, asize, ndim, idim, dim[5], pos, i;
	double		**a;
	double		fm;

	/* defaults */
	suffix = defsuffix;
	xname = NULL;

	/* parse args */
	if (argc < 2)
		error_exit(usage);
	parfilename = argv[1];
	if (!strcmp(parfilename, "-u")) {
		error_exit(usage);
	}
	while (arg < argc) {
		if (argv[arg][0] != '-') {
			error_exit(usage);
		} else {
			switch (argv[arg++][1]) {
				case 'x':
					xname = argv[arg++];
					break;
				case 's':
					suffix = argv[arg++];
					break;
				default:
					error_exit(usage);
					break;
			}
		}
	}

	/* read the parameter file */
	get2Dpolymodel(parfilename, &l, &m, &asize, &a, &nmodes, &nvar, vardef, &parfilexname);
	if (!xname) {
		xname = parfilexname;
	}
	sscanf(vardef[2], "%d%n", &ndim, &pos);
	vardef[2]+= pos;
	for (idim = 0; idim < ndim; idim++) {
		sscanf(vardef[2], "%d%n", &(dim[idim]), &pos);
		vardef[2]+= pos;
	}
	sscanf(vardef[2], "%s", varname);
	strcat(varname, suffix);
	
	setcatopfiletype(BINARY_FILE_TYPE);	

	inputcathead = readcathead();			/* read the cat head */
	inputobject = newobject(inputcathead);		/* make the input object */
	connectobjecttocathead(inputobject);		/* obj addresses point back to cathead */
	allocobjectcontents(inputobject);		/* and allocate space for obj data */

	outputcathead = (cathead *) calloc(1, sizeof(cathead));			/* new cathead */
	copyheaderinfo(outputcathead, inputcathead);				/* copy header stuff */

	addargscomment(argc, argv, outputcathead);		/* add history */

	copycontentinfo(outputcathead, inputcathead);		/* copy over pre-exisiting object items */
	modelvalitem = newitembydimarray(varname, NUM_TYPE, ndim, dim);
	addobjectitem(modelvalitem, outputcathead);
	writecathead(outputcathead);				/* and write cathead out */			
	outputobject = newobject(outputcathead);		/* make the output object */
 	imodelval = getobjectitemindex(varname, outputobject);	/* get indices for new items */
	inheritcontents(outputobject, inputobject);		/* pre-existing output object addresses point back to inputobject */
 	allocitemcontents(modelvalitem, &((outputobject->addrlist)[imodelval]), 0);	/*allocate space for new data */
 	modelval = (void *) ((outputobject->addrlist)[imodelval]);	/*get local handles for the new items. */

	/* now we get the handles to the input object items we will need */
	x = (double *) ((inputobject->addrlist)[getobjectitemindex("x", inputobject)]);

	/* get a 1D array of pointers to modelval contents */
	var = (double **) calloc(asize, sizeof(double *));
	varind = 0;
	getaddresses(modelval, ndim, dim);



	while (readobject(inputobject)) {					/* big loop */
		for (i = 0; i < asize; i++) {
			*(var[i]) = 0.0;
		}
		for (mode = 0; mode < nmodes; mode++) {
			fm = f(l[mode], m[mode], x);
			for (i = 0; i < asize; i++) {
				*(var[i]) += a[i][mode] * fm;
			}
		}
		writeobject(outputobject);
	}
	exit(0);
}



/* recursive function to get addresses of arbitrary dimension array */
void	getaddresses(void *addr, int ndim, int *dim)
{
	int	idim;

	if (ndim == 1) {
		var[varind++] = (double *) addr;
		for (idim = 1; idim < dim[0]; idim++) {
			var[varind] = var[varind - 1] + 1;
			varind++;
		}
	} else {
		for (idim = 0; idim < dim[0]; idim++) {
			getaddresses(((void **) addr)[idim], ndim - 1, dim + 1);
		}
	}
}